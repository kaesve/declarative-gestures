<!DOCTYPE html>
<title>Declarative gestures -- demo page</title>
<style>
  body,html {
    margin: 0; padding: 0;
    font: 20px/1.5 sans-serif;
    text-shadow: 0 1px #fff, 0 -1px #fff, 1px 0 #fff, -1px 0 #fff;
  }

  .object {
    display: table;
    border-radius: 5px;
    position: absolute;
    width: 100px; height: 100px;
  }
  .object:after {
    content: attr(id);
    display: table-cell;
    vertical-align: middle;
    text-align: center;
  }

  

  #obj-1 { background: rgba(255, 100, 100, .75); top: 10px; left: 10px; }
  #obj-2 { background: rgba(100, 255, 100, .75); top: 10px; left: 120px; }
  #obj-3 { background: rgba(100, 100, 255, .75); top: 120px; left: 10px;}
</style>

<div class="object" id="obj-1"></div>
<div class="object" id="obj-2"></div>
<div class="object" id="obj-3"></div>

<script>

var testGesture = "d1/obj-(2|3)/m1*u1";
var actionPattern = /([dmu])(\d+)(?:\/([^\/]*)\/)?/g;
var modifierPattern = /(\+|\||\*|(?:\{\d+(?:, *\d+)\}))/g; // matches +, *, |, {12} and {12, 24}

function modifierAsString(modifier) { return '{' + modifier.min + ',' + modifier.max + '}'; }

function parseModifier(data) {
  var modifier;
  switch(data.string[data.pos]) {
    case '+': modifier = { min: 1, max: Infinity }; break;
    case '*': modifier = { min: 0, max: Infinity }; break;
    case '?': modifier = { min: 0, max: 1 }; break;
    case '{': 
      // not sure if this is efficient. Depends on substr implementation
      var delimData = /^\{(\d+),?(\d+)?\}/.exec(data.string.substr(data.pos));
      data.pos += delimData[0].length - 1; // -1 to account for the data.pos++ at the end
      modifier = {
        min: +delimData[1],
        max: +delimData[2] || +delimData[1]
      };
    break;
    default: return { min: 1, max: 1 };
  }
  data.pos++;
  return modifier;
}
function parseNode(data) {
  var options = [];
  data.pos--;
  do {
    data.pos++;
    options.push(parseGroupOrAction(data))
  } while (data.string[data.pos] == '|');

  if (options.length > 1) {
    return {
      type: 'options',
      options: options,
      string: options.map(function(o) { return o.string; }).join('|')
    };
  } else {
    return options[0]; 
  } 
}
function parseGroupOrAction(data) {
  var c = data.string[data.pos];
  if (c == undefined) return;

  if (c == '(') return parseGroup(data);
  else return parseAction(data);
}
function parseAction(data) {
  actionPattern.lastIndex = data.pos;
  var actionMatch = actionPattern.exec(data.string);
  data.pos = actionPattern.lastIndex;
  var modifier = parseModifier(data);
  return {
    type: 'action',
    action: actionMatch[1],
    id: actionMatch[2],
    target: actionMatch[3] || '/.*/',
    modifier: modifier,
    string: actionMatch[0] + modifierAsString(modifier)
  };
}
function parseGroup(data) {
  var children = []
  data.pos++; // skip '(' 
  while (data.string[data.pos] != ')') children.push(parseNode(data));
  data.pos++; // skip ')'
  var modifier = parseModifier(data);
  return {
    type: 'group',
    children: children,
    modifier: modifier,
    string: '(' + children.map(function(c) { return c.string; }).join('') + ')' + modifierAsString(modifier)
  };
}
function parseGestures(gestureString) {
  var tokens = [];
  var data = { string: gestureString, pos: 0 };
  while (data.pos < data.string.length) tokens.push(parseNode(data));
  return tokens;
}

function stateMachineForAction(entryState, endState, action) {
  var current = entryState;
  var id = action.action + action.id;
  for (var repeats = 0; repeats < action.modifier.min; ++repeats) {
    current.transitions[id] = current.transitions[id] || { };
    current = current.transitions[id][action.target] = { transitions: { '': [ ] } }; 
  }

  current.transitions[''].push(endState);
  if (action.modifier.max == Infinity) {
    current.transitions[id] = current.transitions[id] || { };
    current.transitions[id][action.target] = current; 
  } else {
    while (repeats++ < action.modifier.max) {
      current.transitions[id] = current.transitions[id] || { };
      current = current.transitions[id][action.target] = { transitions: { '': [ endState ] } };
    }
  }
}
function stateMachineForGroup(entryState, endState, group) {
  var current = entryState;
  for (var repeats = 0; repeats < group.modifier.min; ++repeats) {
    current = group.children.reduce(function(state, e) { 
      var n = { transitions: { '' : [ ] } };
      stateMachineForExpression(state, n, e);
      return n;
    }, current);
  }
  current.transitions[''].push(endState);

  if (group.modifier.max == Infinity) {
    current = group.children.reduce(function(state, e) { 
      var n = { transitions: { '' : [ ] } };
      stateMachineForExpression(state, n, e);
      return n;
    }, current);
    current.transitions[''].push(endState);
    current.transitions[''].push(current);
  } else {
    while(repeats++ < group.modifier.max) { 
      current = group.children.reduce(function(state, e) { 
        var n = { transitions: { '' : [ ] } };
        stateMachineForExpression(state, n, e);
        return n;
      }, current);
      current.transitions[''].push(endState);
    }
  }
}
function stateMachineForOptions(entryState, endState, options) {
  options.options.forEach(stateMachineForExpression.bind(this, entryState, endState));
}
function stateMachineForExpression(entryState, endState, e) {
  var f;
  switch(e.type) {
    case 'action':  f = stateMachineForAction;  break;
    case 'group':   f = stateMachineForGroup;   break;
    case 'options': f = stateMachineForOptions; break;
  }
  f(entryState, endState, e);
}
function computeStateMachine(gestureTokens) {
  var gestureGroup = {
    type: 'group',
    children: gestureTokens,
    modifier: { min: 1, max: 1 }
  };

  var initialState = { transitions: { '': [] } };
  var endState = { thisIsTheEND: true };
  stateMachineForGroup(initialState, endState, gestureGroup);
  return initialState;
}

</script>